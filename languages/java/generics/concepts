Why generics?
- Collections are by nature hetrogenous. They can contain any object.
- Generics stop runtime errors at compile time.
- Type-safety without copy and paste


Binary compatibility of generics:
----------------------------------
You can replace a legacy class file with a generic class file without changing or recompiling any client code.

Steps to make a class generics:
-------------------------------
1) CircularBuffer<T> ->  Make class name generics
2) Make parameters as T -> private T[] buffer; final T value;
3) Castings should be made this way -> (T[]) new Object[size];
4) Change method parameters  and return value ->  offer(T value) & public T poll()
5) Initialize collection as Circular<String>  buffer = new Circular<String>();
6) They make code Typesafe

When in constructor you dont want parameters to be null:

public Person(String name, int age){
  Objects.requireNonNull(name);
  this.name=name;
  this.age=age;
}


# Here we have generic recipies:
--------------------------------

1) Implement a generic type:
-------------------------
public class AgeComparator implements Comparator<ClassName>{
 public int compare(final Person o1,final Person o2){
     return 0; //Integer.compare(o1.getAge(),o2.getAge()) [Multiply this by -1 for negative]
 }
}

Collections.sort(list,new AgeComparator())


2) Passing parameter to generic type:
----------------------------------
If you want a reverse version of any comparator, use:

public class ReverseComparator<T> implements Comparator<T>
{
   private final Comparator<T> delegateComparator;

   public ReverseComparator(final Comparator<T>delegateComparator){
       this.delegateComparator = delegateComparator;
   }

   public int compare(final T left, final T right){
       return -1* delegateComparator.compare(left,right);
   }
}

Collections.sort(list,new ReverseComparator<>(AgeComparator()))

3) Type bounds:
----------------

public class SortedPair<T extends Comparable<T>>{

   private final T first;
   private final T second;

   public SortedPair(T left, T right){
     if(left.compareTo(right)<0){
         firs=left;
         second=right;
     }
     else{
         first=right;
         second=left;
     }
   }
}